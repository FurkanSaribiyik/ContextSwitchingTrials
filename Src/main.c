/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>


#define SIZE_TASK_STACK 1024U
#define SRAM_START 0X20000000U
#define SRAM_SIZE ((128)*(1024))
#define SRAM_END ((SRAM_START)+(SRAM_SIZE))

#define T1_STACK_START SRAM_END
#define T2_STACK_START ((SRAM_END) -(1*SIZE_TASK_STACK))
#define T3_STACK_START ((SRAM_END) -(2*SIZE_TASK_STACK))
#define T4_STACK_START ((SRAM_END) -(3*SIZE_TASK_STACK))
#define SCHED_STACK_START ((SRAM_END) -(4*SIZE_TASK_STACK))

#define TICK_HZ	1000U
#define CPU_CLK 16000000U
#define SYSTICK_CLK CPU_CLK

#define NUMBEROF_TASKS 4

void task1(void);
void task2(void);
void task3(void);
void task4(void);

void init_systick_timer(uint32_t tickHz);
__attribute((naked)) void init_scheduler_stack(uint32_t scheduleraddr);
__attribute((naked)) void switch_to_PSP(void);
void init_task_stacks(void);
uint32_t get_psp_value(void);


uint32_t psp_of_tasks[NUMBEROF_TASKS]={T1_STACK_START,T2_STACK_START,T3_STACK_START,T4_STACK_START};
uint32_t tasks[NUMBEROF_TASKS];
uint8_t current_task=0;
int main(void)
{
	init_scheduler_stack(SCHED_STACK_START);
	tasks[0]=(uint32_t)task1;
	tasks[1]=(uint32_t)task2;
	tasks[2]=(uint32_t)task3;
	tasks[3]=(uint32_t)task4;
	init_task_stacks();
	init_systick_timer(TICK_HZ);
	switch_to_PSP();
	task1();
	for(;;);
}

void save_psp_value(uint32_t psp_addr)
{
	psp_of_tasks[current_task]=psp_addr;
}

void set_next_task(void)
{
	++current_task;
	current_task%=NUMBEROF_TASKS;
}

__attribute((naked)) void SysTick_Handler(void)
{
	__asm volatile ("MRS R0,PSP");		//saving the current value of the PSP
	__asm volatile ("STMDB R0!,{R4-R11}");	//saving the remaining piece of the stack frame

	__asm volatile ("PUSH {LR}");		//Save the return value in order to go back and forth between functions
	__asm volatile ("BL save_psp_value");	//Saving the location of PSP

	__asm volatile ("BL set_next_task");

	__asm volatile ("BL get_psp_value");	//get the psp of the next task

	__asm volatile ("LDMIA R0!,{R4-R11}");	//recover the bottom of the stack frame of the next task, the rest of the frame will be recovered at the end of the interrupt

	__asm volatile ("MSR PSP,R0");

	__asm volatile ("POP {LR}");

	__asm volatile ("BX LR");		//return to main

}

uint32_t get_psp_value(void)
{
	return psp_of_tasks[current_task];
}

__attribute((naked)) void switch_to_PSP(void)
{
	__asm volatile ("PUSH {LR}");			//Save the return value to jump to another function
	__asm volatile ("BL get_psp_value");	//Get PSP of the current stack and store it in R0
	__asm volatile ("POP {LR}");
	__asm volatile ("MSR PSP,R0");			//PSP value is loaded into PSP register

	__asm volatile ("MOV R0,#0X02");
	__asm volatile ("MSR CONTROL,R0");		//Set main SP as PSP
	__asm volatile ("BX LR");		//Return to main
}


void init_task_stacks(void)
{
	uint32_t *pPSP;
	for(int i=1;i<NUMBEROF_TASKS;i++)		//the stackframe of task1 will be loaded when the systick interrupt triggers
	{
		pPSP=(uint32_t *)psp_of_tasks[i];
		--pPSP;
		*pPSP=0x01000000;	//Setting xPSR register with reset value, T bit is set as 1
		--pPSP;
		*pPSP=tasks[i];		//Address of the function/tasks
		--pPSP;
		*pPSP=0xFFFFFFFD;	//Loading LR with exception return to handler mode that returns with PSP as SP
		for(int k=0;k<13;k++)
		{
			--pPSP;
			*pPSP=0;
		}
		psp_of_tasks[i]=(uint32_t)pPSP;			//
	}
}


__attribute((naked)) void init_scheduler_stack (uint32_t scheduleraddr)
{
	__asm volatile ("MSR MSP,R0");
	__asm volatile ("BX LR");
}

void init_systick_timer(uint32_t tickHz)
{
	uint32_t counter=(SYSTICK_CLK/tickHz)-1;		//calculating how many ticks are necessary for the requested time frequency
	uint32_t* Systick_Control_Reg=(uint32_t *)0xE000E010;
	uint32_t* Systick_Counter_Reg=(uint32_t *)0xE000E014;

	*Systick_Control_Reg|=(7<<0);				/* Enabling counter register countdown, Systick exception and choosing internal processor clock 16Mhz*/

	*Systick_Counter_Reg&=~(0x00FFFFFF);	//clearing Counter Register
	*Systick_Counter_Reg|=(counter<<0);

}


void task1(void)
{
	while(1)
	{
		printf("This is task 1 \n");
	}
}
void task2(void)
{
	while(1)
	{
		printf("This is task 2 \n");
	}
}

void task3(void)
{
	while(1)
	{
		printf("This is task 3 \n");
	}
}

void task4(void)
{
	while(1)
	{
		printf("This is task 4 \n");
	}
}





